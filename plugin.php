<?php
/**
 * Plugin Name:       Query Posts Grouped by Taxonomy
 * Description:       Extends the core Query Loop block with a "Group by Taxonomy" option, enabling grouped front-end output by any selected taxonomy.
 * Version:           0.1.0
 * Requires at least: 6.4
 * Requires PHP:      7.4
 * Author:            carstenbach
 * License:           GPLv2 or later
 * License URI:       https://www.gnu.org/licenses/gpl-2.0.html
 * Text Domain:       query-groupedby-taxonomy
 *
 * @package QueryGroupedbyTaxonomy
 */

// Exit if accessed directly.
defined( 'ABSPATH' ) || exit; // @codeCoverageIgnore

if ( ! class_exists( 'Query_Groupedby_Taxonomy' ) ) {

	/**
	 * Main plugin class implementing the Singleton pattern.
	 *
	 * Registers editor assets, custom block attributes, REST API parameters,
	 * and SQL modifications for taxonomy-based grouping of the core Query
	 * Loop block.
	 *
	 * @since 0.1.0
	 */
	class Query_Groupedby_Taxonomy {

		/**
		 * Private constructor to prevent direct instantiation.
		 *
		 * Registers all WordPress hooks required by the plugin.
		 *
		 * @since 0.1.0
		 */
		private function __construct() {
			add_action( 'init', array( $this, 'register_assets' ) );
			add_action( 'init', array( $this, 'register_rest_params' ), PHP_INT_MAX );
			add_action( 'enqueue_block_editor_assets', array( $this, 'enqueue_editor_assets' ) );
			add_filter( 'block_type_metadata', array( $this, 'register_block_attributes' ) );
			add_filter( 'pre_render_block', array( $this, 'pre_render' ), 10, 2 );
		}

		/**
		 * Register the editor script and style for the Query block extension.
		 *
		 * @since 0.1.0
		 *
		 * @return void
		 */
		public function register_assets(): void {
			$asset_file = __DIR__ . '/build/index.asset.php';

			if ( ! file_exists( $asset_file ) ) {
				return;
			}

			/**
			 * Asset metadata generated by @wordpress/scripts build.
			 *
			 * @var array{dependencies: string[], version: string} $asset
			 */
			$asset = include $asset_file; // phpcs:ignore WordPressVIPMinimum.Files.IncludingFile.UsingVariable -- We trust the generated asset file.

			wp_register_script(
				'query-groupedby-taxonomy',
				plugins_url( 'build/index.js', __FILE__ ),
				$asset['dependencies'],
				$asset['version'],
				true
			);

			wp_register_style(
				'query-groupedby-taxonomy-editor',
				plugins_url( 'build/editor.css', __FILE__ ),
				array(),
				$asset['version']
			);
		}

		/**
		 * Enqueue the extension script and style in the block editor.
		 *
		 * @since 0.1.0
		 *
		 * @return void
		 */
		public function enqueue_editor_assets(): void {
			wp_enqueue_script( 'query-groupedby-taxonomy' );
			wp_enqueue_style( 'query-groupedby-taxonomy-editor' );
		}

		/**
		 * Register the custom groupByTaxonomy attribute on the core/query block
		 * via the block_type_metadata filter.
		 *
		 * @since 0.1.0
		 *
		 * @param array<string, mixed> $metadata Block type metadata.
		 *
		 * @return array<string, mixed> Modified metadata with the groupByTaxonomy attribute.
		 */
		public function register_block_attributes( array $metadata ): array {
			$block_name = isset( $metadata['name'] ) && is_string( $metadata['name'] )
				? $metadata['name']
				: '';

			if ( 'core/query' !== $block_name ) {
				return $metadata;
			}

			if ( ! isset( $metadata['attributes'] ) || ! is_array( $metadata['attributes'] ) ) {
				$metadata['attributes'] = array();
			}

			$metadata['attributes']['groupByTaxonomy'] = array(
				'type'    => 'string',
				'default' => '',
			);

			return $metadata;
		}

		/**
		 * Register the groupByTaxonomy REST API parameter for all public post types
		 * and hook into their REST queries to apply the same SQL modifications
		 * used on the front end.
		 *
		 * This ensures the block editor preview reflects the grouped/filtered results.
		 *
		 * @since 0.1.0
		 *
		 * @return void
		 */
		public function register_rest_params(): void {
			$post_types = get_post_types( array( 'public' => true ) );

			foreach ( $post_types as $post_type ) {
				add_filter(
					"rest_{$post_type}_collection_params",
					array( $this, 'add_rest_collection_params' ),
					10,
					1
				);

				add_filter(
					"rest_{$post_type}_query",
					array( $this, 'handle_rest_query' ),
					10,
					2
				);
			}
		}

		/**
		 * Add the groupByTaxonomy parameter to the REST API collection params
		 * schema so it is accepted as a valid query parameter.
		 *
		 * @since 0.1.0
		 *
		 * @param array<string, mixed> $params The existing collection parameters.
		 *
		 * @return array<string, mixed> Modified collection parameters.
		 */
		public function add_rest_collection_params( array $params ): array {
			$params['groupByTaxonomy'] = array(
				'description'       => __( 'Taxonomy slug to group results by.', 'query-groupedby-taxonomy' ),
				'type'              => 'string',
				'default'           => '',
				'sanitize_callback' => 'sanitize_text_field',
				'validate_callback' => 'rest_validate_request_arg',
			);

			return $params;
		}

		/**
		 * Handle the groupByTaxonomy parameter in REST API queries.
		 *
		 * When the parameter is present and valid, injects the custom query
		 * variable and attaches the posts_clauses filter so the editor preview
		 * receives the same grouped/filtered results as the front end.
		 *
		 * @since 0.1.0
		 *
		 * @param array<string, mixed> $args    The WP_Query arguments for the REST request.
		 * @param \WP_REST_Request     $request The REST request object.
		 *
		 * @return array<string, mixed> Modified query arguments.
		 */
		public function handle_rest_query( array $args, \WP_REST_Request $request ): array {
			$raw_taxonomy = $request->get_param( 'groupByTaxonomy' );

			if ( empty( $raw_taxonomy ) || ! is_string( $raw_taxonomy ) ) {
				return $args;
			}

			$taxonomy = sanitize_text_field( $raw_taxonomy );

			if ( '' === $taxonomy || ! taxonomy_exists( $taxonomy ) ) {
				return $args;
			}

			$args['qgbt_group_taxonomy'] = $taxonomy;

			// Attach the posts_clauses filter for this REST query.
			add_filter( 'posts_clauses', array( $this, 'modify_clauses' ), 10, 2 );

			return $args;
		}

		/**
		 * Modify the SQL clauses of the Query Loop's WP_Query to join taxonomy
		 * tables and order results by term name, enabling grouped output.
		 *
		 * This filter is added dynamically by the pre_render callback or the
		 * REST query handler and removes itself after first execution to avoid
		 * affecting other queries.
		 *
		 * @since 0.1.0
		 *
		 * @param array<string, string> $clauses  Associative array of SQL clauses (fields, join, where, groupby, orderby, etc.).
		 * @param \WP_Query             $wp_query The WP_Query instance.
		 *
		 * @return array<string, string> Modified clauses with taxonomy join and ordering.
		 */
		public function modify_clauses( array $clauses, \WP_Query $wp_query ): array {
			/**
			 * WordPress Database constant
			 *
			 * @var \wpdb $wpdb
			 */
			global $wpdb;

			$raw_taxonomy = $wp_query->get( 'qgbt_group_taxonomy' );

			if ( empty( $raw_taxonomy ) || ! is_string( $raw_taxonomy ) ) {
				return $clauses;
			}

			$taxonomy = sanitize_text_field( $raw_taxonomy );

			if ( '' === $taxonomy || ! taxonomy_exists( $taxonomy ) ) {
				return $clauses;
			}

			$taxonomy_escaped = esc_sql( $taxonomy );

			$posts_table              = $wpdb->posts;
			$term_relationships_table = $wpdb->term_relationships;
			$term_taxonomy_table      = $wpdb->term_taxonomy;
			$terms_table              = $wpdb->terms;

			// Join the term_relationships, term_taxonomy, and terms tables.
			$join  = " INNER JOIN {$term_relationships_table} AS qgbt_tr ON ( {$posts_table}.ID = qgbt_tr.object_id )";
			$join .= " INNER JOIN {$term_taxonomy_table} AS qgbt_tt ON ( qgbt_tr.term_taxonomy_id = qgbt_tt.term_taxonomy_id AND qgbt_tt.taxonomy = '{$taxonomy_escaped}' )";
			$join .= " INNER JOIN {$terms_table} AS qgbt_t ON ( qgbt_tt.term_id = qgbt_t.term_id )";

			$clauses['join'] = ( isset( $clauses['join'] ) ? $clauses['join'] : '' ) . $join;

			/*
			 * Group by term slug so that only one post per term is returned.
			 *
			 * Given the strict one-term-per-post policy, when multiple posts
			 * share the same term (e.g. two posts tagged "apples"), we want
			 * only the most recent one. GROUP BY on the term slug collapses
			 * all posts under the same term into a single row, and
			 * MAX( wp_posts.ID ) picks the newest post (highest ID).
			 *
			 * We also use a subquery in WHERE to ensure the surviving post ID
			 * is the one with the latest post_date for that term, which is
			 * more reliable than relying on MAX(ID) alone.
			 */
			$clauses['groupby'] = 'qgbt_t.slug';

			// Add the term slug and max date to the selected fields.
			$existing_fields   = isset( $clauses['fields'] ) ? $clauses['fields'] : '';
			$clauses['fields'] = $existing_fields . ", qgbt_t.slug AS qgbt_term_slug, MAX( {$posts_table}.post_date ) AS qgbt_max_date";

			/*
			 * Use a subquery in WHERE to ensure only the newest post per term
			 * survives. Since GROUP BY qgbt_t.slug collapses rows, we limit to
			 * posts whose ID equals the newest post for each term.
			
			$existing_where   = isset( $clauses['where'] ) ? $clauses['where'] : '';
			$clauses['where'] = $existing_where . " AND {$posts_table}.ID IN (
				SELECT latest_posts.post_id FROM (
					SELECT qgbt_sub_tr.object_id AS post_id, qgbt_sub_t.slug AS term_slug, MAX( sub_p.post_date ) AS max_date
					FROM {$posts_table} AS sub_p
					INNER JOIN {$term_relationships_table} AS qgbt_sub_tr ON ( sub_p.ID = qgbt_sub_tr.object_id )
					INNER JOIN {$term_taxonomy_table} AS qgbt_sub_tt ON ( qgbt_sub_tr.term_taxonomy_id = qgbt_sub_tt.term_taxonomy_id AND qgbt_sub_tt.taxonomy = '{$taxonomy_escaped}' )
					INNER JOIN {$terms_table} AS qgbt_sub_t ON ( qgbt_sub_tt.term_id = qgbt_sub_t.term_id )
					WHERE sub_p.post_status = 'publish'
					GROUP BY qgbt_sub_t.slug
					HAVING sub_p.post_date = MAX( sub_p.post_date )
				) AS latest_posts
			)"; */

			// Order primarily by the term slug, then by any existing orderby.
			$existing_orderby   = isset( $clauses['orderby'] ) ? trim( $clauses['orderby'] ) : '';
			$clauses['orderby'] = 'qgbt_term_slug ASC' . ( '' !== $existing_orderby ? ", {$existing_orderby}" : '' );

			// Remove self after first execution to avoid affecting other queries.
			remove_filter( 'posts_clauses', array( $this, 'modify_clauses' ), 10 );

			return $clauses;
		}

		/**
		 * Hook into pre_render_block to detect core/query blocks with the
		 * groupByTaxonomy attribute and attach the posts_clauses filter
		 * before the query executes.
		 *
		 * Uses the query_loop_block_query_vars filter to inject custom query
		 * variables into the Query Loop's own WP_Query instance.
		 *
		 * @since 0.1.0
		 *
		 * @param string|null          $pre_render   The pre-rendered content. Default null.
		 * @param array<string, mixed> $parsed_block The block being rendered.
		 *
		 * @return string|null Null to allow normal rendering to proceed.
		 */
		public function pre_render( ?string $pre_render, array $parsed_block ): ?string {
			$block_name = isset( $parsed_block['blockName'] ) && is_string( $parsed_block['blockName'] )
				? $parsed_block['blockName']
				: '';

			if ( 'core/query' !== $block_name ) {
				return $pre_render;
			}

			$raw_taxonomy = isset( $parsed_block['attrs'] ) && is_array( $parsed_block['attrs'] ) && isset( $parsed_block['attrs']['groupByTaxonomy'] )
				? $parsed_block['attrs']['groupByTaxonomy']
				: '';

			if ( ! is_string( $raw_taxonomy ) || '' === $raw_taxonomy ) {
				return $pre_render;
			}

			$taxonomy = sanitize_text_field( $raw_taxonomy );

			if ( '' === $taxonomy || ! taxonomy_exists( $taxonomy ) ) {
				return $pre_render;
			}

			// Inject custom query vars via the query_loop_block_query_vars filter.
			add_filter(
				'query_loop_block_query_vars',
				/**
				 * Add custom query variables to the Query Loop's WP_Query.
				 *
				 * @param array<string, mixed> $query_vars The query variables.
				 *
				 * @return array<string, mixed> Modified query variables with taxonomy grouping flag.
				 */
				static function ( array $query_vars ) use ( $taxonomy ): array {
					$query_vars['qgbt_group_taxonomy'] = $taxonomy;
					return $query_vars;
				}
			);

			// Attach the posts_clauses filter to modify the next WP_Query.
			add_filter( 'posts_clauses', array( $this, 'modify_clauses' ), 10, 2 );

			// Return null to allow normal block rendering to proceed.
			return $pre_render;
		}

		/**
		 * The single instance of this class.
		 *
		 * @since 0.1.0
		 *
		 * @var Query_Groupedby_Taxonomy|null
		 */
		private static ?Query_Groupedby_Taxonomy $instance = null;

		/**
		 * Retrieve the singleton instance.
		 *
		 * @since 0.1.0
		 *
		 * @return Query_Groupedby_Taxonomy The singleton instance.
		 */
		public static function get_instance(): Query_Groupedby_Taxonomy {
			if ( null === self::$instance ) {
				self::$instance = new self();
			}

			return self::$instance;
		}

		/**
		 * Prevent cloning of the singleton.
		 *
		 * @since 0.1.0
		 *
		 * @return void
		 */
		private function __clone() {}

		/**
		 * Prevent unserialization of the singleton.
		 *
		 * @since 0.1.0
		 *
		 * @throws \RuntimeException Always, to prevent unserialization.
		 *
		 * @return void
		 */
		public function __wakeup(): void {
			throw new \RuntimeException( 'Cannot unserialize singleton.' );
		}
	}
}

// Initialize the singleton.
Query_Groupedby_Taxonomy::get_instance();
